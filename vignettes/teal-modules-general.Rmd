---
title: "Getting started with teal.modules.general"
author: "NEST CoreDev Team"
date: "01.04.2022"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Getting started with teal.modules.general}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

### Introduction

`teal` is a package that extends the `shiny` framework to build interactive GUI applications using the R programming
language. `shiny`, and hence `teal`, are implemented to allow the building of large applications by combining small,
decoupled modules. `teal.modules.general` is a package consisting of a set of modules that are used to build `teal`
applications. It is "general" in the sense that the intended functions of these modules are more fundamental. This is
in contrast to the intended functions of its sister package, `teal.modules.clinical`, which is more specialized around
clinical data. The modules of `teal.modules.general` can be combined with modules of `teal.modules.clinical` and / or
other `shiny` modules to build a large `teal` / `shiny` app.

The concepts presented here require knowledge about the core features of `teal`, specifically on how to launch a `teal`
application and how to pass data into it. Therefore, it is highly recommended to refer to the [`README`](https://insightsengineering.github.io/teal/index.html) file and 
the introductory [vignette](https://insightsengineering.github.io/teal/articles/teal.html) of the `teal` package.

See also `teal.modules.clinical's` [`README`](https://insightsengineering.github.io/teal.modules.clinical/index.html).

### Main features

There are five areas of data science that `teal.modules.general` provides tools and solutions (modules) for:

- viewing data in tabular form
- visualizing data in plots and graphs
- viewing data and files in a directory
- examining missing and extreme values in data
- performing data analysis

See [package functions / modules](https://insightsengineering.github.io/teal.modules.general/reference/index.html).

### Example application

A simple application including a `tm_variable_browser` module could look like this:
```{r, message = FALSE, results = "hide"}
library(teal.modules.general)

# nolint start
data <- teal_data()
data <- within(data, {
  ADSL <- teal.modules.general::rADSL
  ADTTE <- teal.modules.general::rADTTE
})
datanames <- c("ADSL", "ADTTE")
datanames(data) <- datanames
join_keys(data) <- default_cdisc_join_keys[datanames]
# nolint end

app <- teal::init(
  data = data,
  modules = teal::modules(
    tm_variable_browser(
      label = "Variable browser",
      ggplot2_args = teal.widgets::ggplot2_args(
        labs = list(subtitle = "Plot generated by Variable Browser Module")
      ),
    )
  )
)
```

```{r, eval = FALSE}
shinyApp(app$ui, app$server)
```

Let's break the above app into pieces:
```r
library(teal.modules.general)
```
The line mentioned above imports the library required for this example and loads data from within that library.

Now, we are building a `teal_data` object that will serve as the source of data for the teal app.
`teal_data` not only encapsulates the data for the app, but it also houses the code required to create the data to maintain reproducibility.
To do this, we create an empty `teal_data` object and evaluate code to produce the data within the `teal_data` object,
so both the code and data are stored together.

Following this, we set the `datanames` and `join_keys`.

```r
# nolint start
data <- teal_data()
data <- within(data, {
  ADSL <- teal.modules.general::rADSL
  ADTTE <- teal.modules.general::rADTTE
})
datanames <- c("ADSL", "ADTTE")
datanames(data) <- datanames
join_keys(data) <- default_cdisc_join_keys[datanames]
# nolint end
```

There is no need to load `teal` as `teal.modules.general` already depends on it.

In the next step, we use `teal` to create `shiny` `ui` and `server` functions so we can launch using `shiny`. The `data`
argument tells `teal` about the input data - the two datasets `ADSL` and `ADTTE` - and the `modules`
argument indicates the modules included in the application. Here, we include only one - `tm_variable_browser`.

```{r, results = "hide"}
app <- teal::init(
  data = data,
  modules = teal::modules(
    tm_variable_browser(
      # module name to display in the GUI
      label = "Variable browser",
      # this argument takes a set of arguments to pass to ggplot2.
      # the arguments must have the same names as its ggplot2 counterpart, e.g. `subtitle`
      ggplot2_args = teal.widgets::ggplot2_args(
        labs = list(subtitle = "Plot generated by Variable Browser Module")
      ),
    )
  )
)
```

The `shiny` function `shinyApp` used the `ui` and `server` objects to initialize the `teal` app.

```{r, eval = FALSE}
shiny::shinyApp(app$ui, app$server)
```

In a `teal` app, data and modules are decoupled. In the app above:

- The app developer specified the data and assigned it to the `data` argument.
- The app developer specified the module and assigned it to the `modules` argument.
- The `init` function took these arguments and returned a list, which can be demonstrated by running:

```{r, indent = "     "}
class(app)
```
This list contains two R objects named `ui` and `server`.
```{r, indent = "     "}
names(app)
```

