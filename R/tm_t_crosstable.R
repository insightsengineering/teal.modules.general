#' Create a simple cross-table
#' @md
#'
#' @inheritParams teal::module
#' @inheritParams shared_params
#' @param x (`data_extract_spec` or `list` of multiple `data_extract_spec`)
#'  Object with all available choices with pre-selected option for variable X - row values. In case
#'  of `data_extract_spec` use `select_spec(..., ordered = TRUE)` if table elements should be
#'  rendered according to selection order.
#' @param y (`data_extract_spec` or `list` of multiple `data_extract_spec`)
#'  Object with all available choices with pre-selected option for variable Y - column values
#'  \code{data_extract_spec} must not allow multiple selection in this case.
#'
#' @param show_percentage optional, (`logical`) Whether to show percentages
#'   (relevant only when `x` is a `factor`). Defaults to `TRUE`.
#' @param show_total optional, (`logical`) Whether to show total column. Defaults to `TRUE`.
#'
#' @note For more examples, please see the vignette "Using cross table" via
#'   `vignette("using-cross-table", package = "teal.modules.general")`.
#'
#' @export
#'
#' @examples
#' # Percentage cross table of variables from ADSL dataset
#' library(scda)
#'
#' ADSL <- synthetic_cdisc_data("latest")$adsl
#'
#' app <- init(
#'   data = cdisc_data(
#'     cdisc_dataset("ADSL", ADSL, code = "ADSL <- synthetic_cdisc_data(\"latest\")$adsl"),
#'     check = TRUE
#'   ),
#'   modules = modules(
#'     tm_t_crosstable(
#'       label = "Cross Table",
#'       x = data_extract_spec(
#'         dataname = "ADSL",
#'         select = select_spec(
#'           label = "Select variable:",
#'           choices = variable_choices(ADSL, subset = function(data) {
#'             idx <- !vapply(data, inherits, logical(1), c("Date", "POSIXct", "POSIXlt"))
#'             return(names(data)[idx])
#'           }),
#'           selected = "COUNTRY",
#'           multiple = TRUE,
#'           ordered = TRUE,
#'           fixed = FALSE
#'         )
#'       ),
#'       y = data_extract_spec(
#'         dataname = "ADSL",
#'         select = select_spec(
#'           label = "Select variable:",
#'           choices = variable_choices(ADSL, subset = function(data) {
#'             idx <- vapply(data, is.factor, logical(1))
#'             return(names(data)[idx])
#'           }),
#'           selected = "SEX",
#'           multiple = FALSE,
#'           fixed = FALSE
#'         )
#'       ),
#'       basic_table_args = teal.widgets::basic_table_args(
#'         subtitles = "Table generated by Crosstable Module"
#'       )
#'     )
#'   )
#' )
#' \dontrun{
#' shinyApp(app$ui, app$server)
#' }
#'
tm_t_crosstable <- function(label = "Cross Table",
                            x,
                            y,
                            show_percentage = TRUE,
                            show_total = TRUE,
                            pre_output = NULL,
                            post_output = NULL,
                            basic_table_args = teal.widgets::basic_table_args()) {
  logger::log_info("Initializing tm_t_crosstable")
  if (inherits(x, "data_extract_spec")) x <- list(x)
  if (inherits(y, "data_extract_spec")) y <- list(y)

  checkmate::assert_string(label)
  checkmate::assert_list(x, types = "data_extract_spec")
  checkmate::assert_list(y, types = "data_extract_spec")
  if (any(vapply(y, function(x) x$select$multiple, logical(1)))) {
    stop("'y' should not allow multiple selection")
  }
  checkmate::assert_flag(show_percentage)
  checkmate::assert_flag(show_total)
  checkmate::assert_class(basic_table_args, classes = "basic_table_args")

  ui_args <- as.list(environment())

  server_args <- list(
    label = label,
    x = x,
    y = y,
    basic_table_args = basic_table_args
  )

  module(
    label = label,
    server = srv_t_crosstable,
    ui = ui_t_crosstable,
    ui_args = ui_args,
    server_args = server_args,
    filters = teal.transform::get_extract_datanames(list(x = x, y = y))
  )
}

ui_t_crosstable <- function(id, datasets, x, y, show_percentage, show_total, pre_output, post_output, ...) {
  ns <- NS(id)
  is_single_dataset <- teal.transform::is_single_dataset(x, y)

  join_default_options <- c(
    "Full Join" = "dplyr::full_join",
    "Inner Join" = "dplyr::inner_join",
    "Left Join" = "dplyr::left_join",
    "Right Join" = "dplyr::right_join"
  )

  teal.widgets::standard_layout(
    output = teal.widgets::white_small_well(
      textOutput(ns("title")),
      teal.widgets::table_with_settings_ui(ns("table"))
    ),
    encoding = div(
      ### Reporter
      teal.reporter::simple_reporter_ui(ns("simple_reporter")),
      ###
      tags$label("Encodings", class = "text-primary"),
      teal.transform::datanames_input(list(x, y)),
      teal.transform::data_extract_ui(ns("x"), label = "Row values", x, is_single_dataset = is_single_dataset),
      teal.transform::data_extract_ui(ns("y"), label = "Column values", y, is_single_dataset = is_single_dataset),
      teal.widgets::optionalSelectInput(
        ns("join_fun"),
        label = "Row to Column type of join",
        choices = join_default_options,
        selected = join_default_options[1],
        multiple = FALSE
      ),
      tags$hr(),
      teal.widgets::panel_group(
        teal.widgets::panel_item(
          title = "Table settings",
          checkboxInput(ns("show_percentage"), "Show column percentage", value = show_percentage),
          checkboxInput(ns("show_total"), "Show total column", value = show_total)
        )
      )
    ),
    forms = teal::get_rcode_ui(ns("rcode")),
    pre_output = pre_output,
    post_output = post_output
  )
}

srv_t_crosstable <- function(id, datasets, reporter, label, x, y, basic_table_args) {
  with_reporter <- !missing(reporter) && inherits(reporter, "Reporter")
  moduleServer(id, function(input, output, session) {
    teal.code::init_chunks()

    selector_list <- teal.transform::data_extract_multiple_srv(data_extract = list(x = x, y = y), datasets = datasets)

    observeEvent(
      eventExpr = {
        req(!is.null(selector_list()$x()) && !is.null(selector_list()$y()))
        list(selector_list()$x(), selector_list()$y())
      },
      handlerExpr = {
        if (identical(selector_list()$x()$dataname, selector_list()$y()$dataname)) {
          shinyjs::hide("join_fun")
        } else {
          shinyjs::show("join_fun")
        }
      }
    )

    merge_function <- reactive({
      if (is.null(input$join_fun)) {
        "dplyr::full_join"
      } else {
        input$join_fun
      }
    })

    merged_data_r <- teal.transform::data_merge_srv(
      datasets = datasets,
      selector_list = selector_list,
      merge_function = merge_function
    )

    x_ordered <- reactive({
      selector_list()$x()$select
    })

    create_table <- reactive({
      validate({
        need(!is.null(selector_list()$x()) && !is.null(selector_list()$y()), "Please select row and column values")
      })
      teal.code::chunks_reset()
      teal.code::chunks_push_data_merge(merged_data_r())

      ANL <- teal.code::chunks_get_var("ANL") # nolint

      # As this is a summary
      teal::validate_has_data(ANL, 3)

      x_name <- x_ordered()
      y_name <- as.vector(merged_data_r()$columns_source$y)

      validate(need(!identical(x_name, character(0)), "Please define column for row variable that is not empty."))
      validate(need(!identical(y_name, character(0)), "Please define column for column variable that is not empty."))

      teal::validate_has_data(ANL[, c(x_name, y_name)], 3, complete = TRUE, allow_inf = FALSE)

      is_allowed_class <- function(x) is.numeric(x) || is.factor(x) || is.character(x) || is.logical(x)
      validate(need(
        all(vapply(ANL[x_name], is_allowed_class, logical(1))),
        "Selected row variable has an unsupported data type."
      ))
      validate(need(
        is_allowed_class(ANL[[y_name]]),
        "Selected column variable has an unsupported data type."
      ))

      show_percentage <- input$show_percentage # nolint
      show_total <- input$show_total # nolint

      plot_title <- paste(
        "Cross-Table of",
        paste0(varname_w_label(x_name, ANL), collapse = ", "),
        "(rows)", "vs.",
        varname_w_label(y_name, ANL),
        "(columns)"
      )

      teal.code::chunks_push(
        id = "title_call",
        expression = substitute(
          expr = {
            title <- plot_title
          },
          env = list(plot_title = plot_title)
        )
      )

      labels_vec <- vapply( # nolint
        x_ordered(),
        varname_w_label,
        character(1),
        ANL
      )

      teal.code::chunks_push(
        id = "lyt_call",
        expression = substitute(
          expr = {
            lyt <- basic_tables %>%
              split_call %>% # styler: off
              rtables::add_colcounts() %>%
              tern::summarize_vars(
                vars = x_name,
                var_labels = labels_vec,
                na.rm = FALSE,
                denom = "N_col",
                .stats = c("mean_sd", "median", "range", count_value)
              )
          },
          env = list(
            basic_tables = teal.widgets::parse_basic_table_args(
              basic_table_args = teal.widgets::resolve_basic_table_args(basic_table_args)
            ),
            split_call = if (show_total) {
              substitute(
                expr = rtables::split_cols_by(
                  y_name,
                  split_fun = rtables::add_overall_level(label = "Total", first = FALSE)
                ),
                env = list(y_name = y_name)
              )
            } else {
              substitute(rtables::split_cols_by(y_name), env = list(y_name = y_name))
            },
            x_name = x_name,
            labels_vec = labels_vec,
            count_value = ifelse(show_percentage, "count_fraction", "count")
          )
        )
      )

      teal.code::chunks_push(
        id = "tbl_call",
        expression = substitute(
          expr = {
            ANL <- tern::df_explicit_na(ANL) # nolint
            tbl <- rtables::build_table(lyt = lyt, df = ANL[order(ANL[[y_name]]), ])
            tbl
          },
          env = list(y_name = y_name)
        )
      )

      teal.code::chunks_safe_eval()
    })

    output$title <- renderText({
      create_table()
      teal.code::chunks_get_var("title")
    })

    table <- reactive({
      create_table()
      teal.code::chunks_get_var("tbl")
    })

    teal.widgets::table_with_settings_srv(
      id = "table",
      table_r = table
    )

    show_r_code_title <- reactive(
      if (is.null(selector_list()$x()) || is.null(selector_list()$y())) {
        paste("Cross-Table")
      } else {
        paste(
          "Cross-Table of",
          paste0(merged_data_r()$columns_source$x, collapse = ", "),
          "vs.",
          merged_data_r()$columns_source$y
        )
      }
    )

    teal::get_rcode_srv(
      id = "rcode",
      datasets = datasets,
      datanames = teal.transform::get_extract_datanames(list(x, y)),
      modal_title = show_r_code_title(),
      code_header = show_r_code_title()
    )

    ### REPORTER
    if (with_reporter) {
      card_fun <- function(comment) {
        card <- teal.reporter::TealReportCard$new()
        card$set_name("Cross Table")
        card$append_text("Cross Table", "header2")
        card$append_fs(datasets$get_filter_state())
        card$append_text("Table", "header3")
        card$append_table(table())
        if (!comment == "") {
          card$append_text("Comment", "header3")
          card$append_text(comment)
        }
        card$append_src(paste(get_rcode(
          chunks = teal.code::get_chunks_object(parent_idx = 2L),
          datasets = datasets,
          title = "",
          description = ""
        ), collapse = "\n"))
        card
      }
      teal.reporter::simple_reporter_srv("simple_reporter", reporter = reporter, card_fun = card_fun)
    }
    ###
  })
}
