#' Variable Browser Teal Module
#'
#' The variable browser provides a table with variable names and labels and a
#' plot that visualizes the content of a particular variable.
#'
#' @details Numeric columns with fewer than 30 distinct values can be treated as either factors
#' or numbers with a checkbox allowing users to switch how they are treated (if < 6 unique values
#' then the default is categorical, otherwise it is numeric).
#'
#' @inheritParams teal::module
#' @inheritParams teal.devel::standard_layout
#' @inheritParams shared_params
#' @param datasets_selected (`character`) A vector of datasets which should be
#'   shown and in what order. Names in the vector have to correspond with datasets names.
#'   If vector of length zero (default) then all datasets are shown.
#'
#'
#' @export
#'
#' @examples
#' library(scda)
#'
#' ADSL <- synthetic_cdisc_data("latest")$adsl
#' ADTTE <- synthetic_cdisc_data("latest")$adtte
#'
#' app <- init(
#'   data = cdisc_data(
#'     cdisc_dataset("ADSL", ADSL, code = "ADSL <- synthetic_cdisc_data(\"latest\")$adsl"),
#'     cdisc_dataset("ADTTE", ADTTE, code = "ADTTE <- synthetic_cdisc_data(\"latest\")$adtte"),
#'     check = TRUE
#'   ),
#'   root_modules(
#'     tm_variable_browser(label = "Variable browser")
#'   )
#' )
#' \dontrun{
#' shinyApp(app$ui, app$server)
#' }
tm_variable_browser <- function(label = "Variable Browser",
                                datasets_selected = character(0),
                                pre_output = NULL,
                                post_output = NULL,
                                ggplot2_args = teal.devel::ggplot2_args()) {
  logger::log_info("Initializing tm_variable_browser")
  checkmate::assert_string(label)
  checkmate::assert_character(datasets_selected)
  checkmate::assert_class(ggplot2_args, "ggplot2_args")
  datasets_selected <- unique(datasets_selected)

  module(
    label,
    server = srv_variable_browser,
    ui = ui_variable_browser,
    filters = "all",
    server_args = list(datasets_selected = datasets_selected, ggplot2_args = ggplot2_args),
    ui_args = list(
      datasets_selected = datasets_selected,
      pre_output = pre_output,
      post_output = post_output
    )
  )
}

# ui function
ui_variable_browser <- function(id,
                                datasets,
                                datasets_selected,
                                pre_output = NULL,
                                post_output = NULL) {
  ns <- NS(id)

  datanames <- get_datanames_selected(datasets, datasets_selected)

  teal.devel::standard_layout(
    output = fluidRow(
      htmlwidgets::getDependency("sparkline"), # needed for sparklines to work
      column(
        6,
        # variable browser
        teal.devel::white_small_well(
          do.call(
            tabsetPanel,
            c(
              id = ns("tabset_panel"),
              do.call(
                tagList,
                stats::setNames(
                  lapply(
                    datanames,
                    function(dataname) {
                      tabPanel(
                        dataname,
                        div(
                          style = "margin-top: 15px;",
                          textOutput(ns(paste0("dataset_summary_", dataname)))
                        ),
                        div(
                          style = "margin-top: 15px;",
                          teal.devel::get_dt_rows(
                            ns(paste0(
                              "variable_browser_", dataname
                            )),
                            ns(
                              paste0("variable_browser_", dataname, "_rows")
                            )
                          ),
                          DT::dataTableOutput(ns(paste0(
                            "variable_browser_", dataname
                          )), width = "100%")
                        )
                      )
                    }
                  ),
                  NULL
                )
              )
            )
          ),
          { # nolint
            x <- checkboxInput(ns("show_parent_vars"), "Show parent dataset variables", value = FALSE)
            if (inherits(datasets, "CDISCFilteredData")) {
              x
            } else {
              shinyjs::hidden(x)
            }
          }
        )
      ),
      column(
        6,
        teal.devel::white_small_well(
          div(
            class = "clearfix",
            style = "margin: 15px 15px 0px 15px;",
            div(
              class = "pull-left",
              shinyWidgets::switchInput(
                inputId = ns("raw_or_filtered"),
                label = "Use filtered data",
                value = TRUE,
                width = "100%",
                labelWidth = "130px",
                handleWidth = "50px"
              )
            )
          ),
          div(
            class = "clearfix;",
            style = "margin: 0px 15px 15px 15px;",
            uiOutput(ns("ui_histogram_display"))
          ),
          div(
            class = "clearfix;",
            style = "margin: 0px 15px 15px 15px;",
            uiOutput(ns("ui_numeric_display"))
          ),
          teal.devel::plot_with_settings_ui(ns("variable_plot")),
          br(),
          teal.devel::get_dt_rows(ns("variable_summary_table"), ns("variable_summary_table_rows")),
          DT::dataTableOutput(ns("variable_summary_table"))
        )
      )
    ),
    pre_output = pre_output,
    post_output = post_output
  )
}

srv_variable_browser <- function(input, output, session, datasets, datasets_selected, ggplot2_args) {

  # if there are < this number of unique records then a numeric
  # variable can be treated as a factor and all factors with < this groups
  # have their values plotted
  .unique_records_for_factor <- 30
  # if there are < this number of unique records then a numeric
  # variable is by default treated as a factor
  .unique_records_default_as_factor <- 6 # nolint

  datanames <- get_datanames_selected(datasets, datasets_selected)
  columns_names <- new.env() # nolint

  # plot_var$data holds the name of the currently selected dataset
  # plot_var$variable[[<dataset_name>]] holds the name of the currently selected
  # variable for dataset <dataset_name>
  plot_var <- reactiveValues(data = NULL, variable = list())

  establish_updating_selection(datanames, input, plot_var, columns_names)

  # validations
  validation_checks <- validate_input(input, plot_var, datasets)

  # data_for_analysis is a list with two elements: a column from a dataset and the column label
  plotted_data <- reactive({
    validation_checks()

    get_plotted_data(input, plot_var, datasets)
  })

  treat_numeric_as_factor <- reactive({
    if (is_num_var_short(.unique_records_for_factor, input, plotted_data)) {
      input$numeric_as_factor
    } else {
      FALSE
    }
  })

  render_tabset_panel_content(
    input = input,
    output = output,
    datasets = datasets,
    datanames = datanames,
    columns_names = columns_names,
    plot_var = plot_var
  )

  output$ui_numeric_display <- renderUI({
    data <- input$tabset_panel
    varname <- plot_var$variable[[input$tabset_panel]]
    type <- input$raw_or_filtered
    req(data, varname, is.logical(type))

    df <- datasets$get_data(data, filtered = type)

    numeric_ui <- tagList(
      fluidRow(
        div(
          class = "col-md-4",
          shinyWidgets::switchInput(
            inputId = session$ns("display_density"),
            label = "Show density",
            value = `if`(is.null(isolate(input$display_density)), TRUE, isolate(input$display_density)),
            width = "50%",
            labelWidth = "100px",
            handleWidth = "50px"
          )
        ),
        div(
          class = "col-md-4",
          shinyWidgets::switchInput(
            inputId = session$ns("remove_outliers"),
            label = "Remove outliers",
            value = `if`(is.null(isolate(input$remove_outliers)), FALSE, isolate(input$remove_outliers)),
            width = "50%",
            labelWidth = "100px",
            handleWidth = "50px"
          )
        ),
        div(
          class = "col-md-4",
          uiOutput(session$ns("outlier_definition_slider_ui"))
        )
      ),
      div(
        style = "margin-left: 15px;",
        uiOutput(session$ns("ui_density_help")),
        uiOutput(session$ns("ui_outlier_help"))
      )
    )

    if (is.numeric(df[[varname]])) {
      unique_entries <- length(unique(df[[varname]]))
      if (unique_entries < .unique_records_for_factor && unique_entries > 0) {
        list(
          checkboxInput(session$ns("numeric_as_factor"),
                        "Treat variable as factor",
                        value = `if`(
                          is.null(isolate(input$numeric_as_factor)),
                          unique_entries < .unique_records_default_as_factor,
                          isolate(input$numeric_as_factor)
                        )
          ),
          conditionalPanel("!input.numeric_as_factor", ns = session$ns, numeric_ui)
        )
      } else if (unique_entries > 0) {
        numeric_ui
      }
    } else {
      NULL
    }
  })

  output$ui_histogram_display <- renderUI({
    data <- input$tabset_panel
    varname <- plot_var$variable[[input$tabset_panel]]
    type <- input$raw_or_filtered
    req(data, varname, is.logical(type))

    df <- datasets$get_data(data, filtered = type)

    numeric_ui <- tagList(fluidRow(
      div(
        class = "col-md-4",
        shinyWidgets::switchInput(
          inputId = session$ns("remove_NA_hist"),
          label = "Remove NA values",
          value = FALSE,
          width = "50%",
          labelWidth = "100px",
          handleWidth = "50px"
        )
      )))

    var <- df[[varname]]
    if (anyNA(var) && (is.factor(var) || is.character(var) || is.logical(var))) {
      groups <- unique(as.character(var))
      len_groups <- length(groups)
      if (len_groups >= .unique_records_for_factor) {
        NULL
      } else {
        numeric_ui
      }
    } else {
      NULL
    }
  })

  output$outlier_definition_slider_ui <- renderUI({
    req(input$remove_outliers)
    sliderInput(
      inputId = session$ns("outlier_definition_slider"),
      div(
        class = "teal-tooltip",
        tagList(
          "Outlier definition:",
          icon("info-circle"),
          span(
            class = "tooltiptext",
            paste(
              "Use the slider to choose the cut-off value to define outliers; the larger the value the",
              "further below Q1/above Q3 points have to be in order to be classed as outliers"
            )
          )
        )
      ),
      min = 1,
      max = 5,
      value = 3,
      step = 0.5
    )
  })

  output$ui_density_help <- renderUI({
    req(is.logical(input$display_density))
    if (input$display_density) {
      tags$small(helpText(paste(
        "Kernel density estimation with gaussian kernel",
        "and bandwidth function bw.nrd0 (R default)"
      )))
    } else {
      NULL
    }
  })

  output$ui_outlier_help <- renderUI({
    req(is.logical(input$remove_outliers), input$outlier_definition_slider)
    if (input$remove_outliers) {
      tags$small(
        helpText(
          withMathJax(paste0(
            "Outlier data points (\\( X \\lt Q1 - ", input$outlier_definition_slider, "\\times IQR \\) or
            \\(Q3 + ", input$outlier_definition_slider, "\\times IQR \\lt X\\))
            have not been displayed on the graph and will not be used for any kernel density estimations, ",
            "although their values remain in the statisics table below."
          ))
        )
      )
    } else {
      NULL
    }
  })


  variable_plot_r <- reactive({
    display_density <- `if`(is.null(input$display_density), FALSE, input$display_density)
    remove_outliers <- `if`(is.null(input$remove_outliers), FALSE, input$remove_outliers)

    if (remove_outliers) {
      req(input$outlier_definition_slider)
      outlier_definition <- as.numeric(input$outlier_definition_slider)
    } else {
      outlier_definition <- 0
    }

    plot_var_summary(
      var = plotted_data()$data,
      var_lab = plotted_data()$var_description,
      numeric_as_factor = treat_numeric_as_factor(),
      remove_NA_hist = input$remove_NA_hist,
      display_density = display_density,
      outlier_definition = outlier_definition,
      records_for_factor = .unique_records_for_factor,
      ggplot2_args = ggplot2_args
    )
  })

  callModule(
    teal.devel::plot_with_settings_srv,
    id = "variable_plot",
    plot_r = variable_plot_r,
    height =  c(500, 200, 2000)
  )

  output$variable_summary_table <- DT::renderDataTable({
    var_summary_table(
      plotted_data()$data,
      treat_numeric_as_factor(),
      input$variable_summary_table_rows,
      if (!is.null(input$remove_outliers) && input$remove_outliers) {
        req(input$outlier_definition_slider)
        as.numeric(input$outlier_definition_slider)
      } else {
        0
      }
    )
  })
}

#' Summarizes missings occurrence
#'
#' Summarizes missings occurrence in vector
#' @param x vector of any type and length
#' @return text describing \code{NA} occurrence.
var_missings_info <- function(x) {
  return(sprintf("%s [%s%%]", sum(is.na(x)), round(mean(is.na(x) * 100), 2)))
}

#' S3 generic for \code{sparkline} widget HTML
#'
#' Generates the \code{sparkline} HTML code corresponding to the input array.
#' For numeric variables creates a box plot, for character and factors - bar plot.
#' Produces an empty string for variables of other types.
#'
#' @param arr vector of any type and length
#' @param width \code{numeric} the width of the \code{sparkline} widget (pixels)
#' @param ... \code{list} additional options passed to bar plots of \code{jquery.sparkline};  see
#' \href{http://omnipotent.net/jquery.sparkline/#common}{\code{jquery.sparkline docs}}
#'
#' @return character variable containing the HTML code of the \code{sparkline} HTML widget
#'
#' @export
#'
create_sparklines <- function(arr, width = 150, ...) {
  if (all(is.null(arr))) {
    return("")
  }
  UseMethod("create_sparklines")
}

#' Default method for \code{\link{create_sparklines}}
#'
#' @inheritParams create_sparklines
#'
#' @export
#'
#' @seealso \code{\link{create_sparklines}}
create_sparklines.default <- function(arr, width = 150, ...) { # nolint
  return(as.character(tags$code("unsupported variable type", style = "color:blue")))
}

#' Generates the HTML code for the \code{sparkline} widget
#'
#' @inheritParams create_sparklines
#' @param bar_spacing \code{numeric} the spacing between the bars (in pixels)
#' @param bar_width \code{numeric} the width of the bars (in pixels)
#'
#' @return \code{character} with HTML code for the \code{sparkline} widget
#'
#' @export
#'
#' @seealso \code{\link{create_sparklines}}
create_sparklines.Date <- function(arr, width = 150, bar_spacing = 5, bar_width = 20, ...) { # nolint
  arr_num <- as.numeric(arr)
  arr_num <- sort(arr_num, decreasing = FALSE, method = "radix")
  binwidth <- get_bin_width(arr_num, 1)
  bins <- floor(diff(range(arr_num)) / binwidth) + 1
  if (all(is.na(bins))) {
    return(as.character(tags$code("only NA", style = "color:blue")))
  } else if (bins == 1) {
    return(as.character(tags$code("one date", style = "color:blue")))
  }
  counts <- as.vector(unname(base::table(cut(arr_num, breaks = bins))))
  max_value <- max(counts)

  start_bins <- as.integer(seq(1, length(arr_num), length.out = bins))
  labels_start <- as.character(as.Date(arr_num[start_bins], origin = as.Date("1970-01-01")))
  labels <- paste("Start:", labels_start)

  sparkline::spk_chr(
    unname(counts),
    type = "bar",
    chartRangeMin = 0,
    chartRangeMax = max_value,
    width = width,
    barWidth = bar_width,
    barSpacing = bar_spacing,
    tooltipFormatter = custom_sparkline_formatter(labels, counts)
  )
}

#' Generates the HTML code for the \code{sparkline} widget
#'
#'
#' @inheritParams create_sparklines
#' @param bar_spacing \code{numeric} the spacing between the bars (in pixels)
#' @param bar_width \code{numeric} the width of the bars (in pixels)
#'
#' @return \code{character} with HTML code for the \code{sparkline} widget
#'
#' @export
#'
#' @seealso \code{\link{create_sparklines}}
create_sparklines.POSIXct <- function(arr, width = 150, bar_spacing = 5, bar_width = 20, ...) { # nolint
  arr_num <- as.numeric(arr)
  arr_num <- sort(arr_num, decreasing = FALSE, method = "radix")
  binwidth <- get_bin_width(arr_num, 1)
  bins <- floor(diff(range(arr_num)) / binwidth) + 1
  if (all(is.na(bins))) {
    return(as.character(tags$code("only NA", style = "color:blue")))
  } else if (bins == 1) {
    return(as.character(tags$code("one date-time", style = "color:blue")))
  }
  counts <- as.vector(unname(base::table(cut(arr_num, breaks = bins))))
  max_value <- max(counts)

  start_bins <- as.integer(seq(1, length(arr_num), length.out = bins))
  labels_start <- as.character(format(as.POSIXct(arr_num[start_bins], origin = as.Date("1970-01-01")), "%Y-%m-%d"))
  labels <- paste("Start:", labels_start)

  sparkline::spk_chr(
    unname(counts),
    type = "bar",
    chartRangeMin = 0,
    chartRangeMax = max_value,
    width = width,
    barWidth = bar_width,
    barSpacing = bar_spacing,
    tooltipFormatter = custom_sparkline_formatter(labels, counts)
  )
}

#' Generates the HTML code for the \code{sparkline} widget
#'
#'
#' @inheritParams create_sparklines
#' @param bar_spacing \code{numeric} the spacing between the bars (in pixels)
#' @param bar_width \code{numeric} the width of the bars (in pixels)
#'
#' @return \code{character} with HTML code for the \code{sparkline} widget
#'
#' @export
#'
#' @seealso \code{\link{create_sparklines}}
create_sparklines.POSIXlt <- function(arr, width = 150, bar_spacing = 5, bar_width = 20, ...) { # nolint
  arr_num <- as.numeric(arr)
  arr_num <- sort(arr_num, decreasing = FALSE, method = "radix")
  binwidth <- get_bin_width(arr_num, 1)
  bins <- floor(diff(range(arr_num)) / binwidth) + 1
  if (all(is.na(bins))) {
    return(as.character(tags$code("only NA", style = "color:blue")))
  } else if (bins == 1) {
    return(as.character(tags$code("one date-time", style = "color:blue")))
  }
  counts <- as.vector(unname(base::table(cut(arr_num, breaks = bins))))
  max_value <- max(counts)

  start_bins <- as.integer(seq(1, length(arr_num), length.out = bins))
  labels_start <- as.character(format(as.POSIXct(arr_num[start_bins], origin = as.Date("1970-01-01")), "%Y-%m-%d"))
  labels <- paste("Start:", labels_start)

  sparkline::spk_chr(
    unname(counts),
    type = "bar",
    chartRangeMin = 0,
    chartRangeMax = max_value,
    width = width,
    barWidth = bar_width,
    barSpacing = bar_spacing,
    tooltipFormatter = custom_sparkline_formatter(labels, counts)
  )
}


#' Generates the HTML code for the \code{sparkline} widget
#'
#' Coerces a character vector to factor and delegates to the \code{create_sparklines.factor}
#'
#' @inheritParams create_sparklines
#'
#' @return \code{character} with HTML code for the \code{sparkline} widget
#'
#' @export
#'
#' @seealso \code{\link{create_sparklines}}
create_sparklines.character <- function(arr, ...) { # nolint
  return(create_sparklines(as.factor(arr)))
}


#' Generates the HTML code for the \code{sparkline} widget
#'
#' Coerces logical vector to factor and delegates to the \code{create_sparklines.factor}
#'
#' @inheritParams create_sparklines
#'
#' @return \code{character} with HTML code for the \code{sparkline} widget
#'
#' @export
#'
#' @seealso \code{\link{create_sparklines}}
create_sparklines.logical <- function(arr, ...) { # nolint
  return(create_sparklines(as.factor(arr)))
}


#' Generates the \code{sparkline} HTML code
#'
#' @inheritParams create_sparklines
#' @param bar_spacing \code{numeric} spacing between the bars (in pixels)
#' @param bar_width \code{numeric} width of the bars (in pixels)
#'
#' @return \code{character} with HTML code for the \code{sparkline} widget
#'
#' @export
#'
#' @seealso \code{\link{create_sparklines}}
create_sparklines.factor <- function(arr, width = 150, bar_spacing = 5, bar_width = 20, ...) { # nolint
  decreasing_order <- TRUE

  counts <- table(arr)
  if (length(counts) >= 100) {
    return(as.character(tags$code("> 99 levels", style = "color:blue")))
  } else if (length(counts) == 0) {
    return(as.character(tags$code("no levels", style = "color:blue")))
  } else if (length(counts) == 1) {
    return(as.character(tags$code("one level", style = "color:blue")))
  }

  # Summarize the occurences of different levels
  # and get the maximum and minimum number of occurences
  # This is needed for the sparkline to correctly display the bar plots
  # Otherwise they are cropped
  counts <- sort(counts, decreasing = decreasing_order, method = "radix")
  max_value <- if (decreasing_order) counts[1] else counts[length[counts]]
  max_value <- unname(max_value)

  sparkline::spk_chr(
    unname(counts),
    type = "bar",
    chartRangeMin = 0,
    chartRangeMax = max_value,
    width = width,
    barWidth = bar_width,
    barSpacing = bar_spacing,
    tooltipFormatter = custom_sparkline_formatter(names(counts), as.vector(counts))
  )
}

#' Generates the \code{sparkline} HTML code
#'
#' @inheritParams create_sparklines
#'
#' @return \code{character} with HTML code for the \code{sparkline} widget
#'
#' @export
#'
#' @seealso \code{\link{create_sparklines}}

create_sparklines.numeric <- function(arr, width = 150, ...) { # nolint
  if (any(is.infinite(arr))) {
    return(as.character(tags$code("infinite values", style = "color:blue")))
  }
  if (length(arr) > 100000) {
    return(as.character(tags$code("Too many rows (>100000)", style = "color:blue")))
  }

  arr <- arr[!is.na(arr)]
  res <- sparkline::spk_chr(unname(arr), type = "box", width = width, ...)
  return(res)
}

#' Summarizes variable
#'
#' Creates html summary with statistics relevant to data type. For numeric values it returns central
#' tendency measures, for factor returns level counts, for Date  date range, for other just
#' number of levels.
#' @param x vector of any type
#' @param numeric_as_factor \code{logical} should the numeric variable be treated as a factor
#' @param dt_rows \code{numeric} current/latest DT page length
#' @param outlier_definition If 0 no outliers are removed, otherwise
#'   outliers (those more than outlier_definition*IQR below/above Q1/Q3 be removed)
#' @return text with simple statistics.
var_summary_table <- function(x, numeric_as_factor, dt_rows, outlier_definition) {
  if (is.null(dt_rows)) {
    dt_rows <- 10
  }
  if (is.numeric(x) && !numeric_as_factor) {
    req(!any(is.infinite(x)))

    x <- remove_outliers_from(x, outlier_definition)

    qvals <- round(stats::quantile(x, na.rm = TRUE, probs = c(0.25, 0.5, 0.75), type = 2), 2)
    # classical central tendency measures

    summary <-
      data.frame(
        Statistic = c("min", "Q1", "median", "mean", "Q3", "max", "sd", "n"),
        Value = c(
          round(min(x, na.rm = TRUE), 2),
          qvals[1],
          qvals[2],
          round(mean(x, na.rm = TRUE), 2),
          qvals[3],
          round(max(x, na.rm = TRUE), 2),
          round(stats::sd(x, na.rm = TRUE), 2),
          length(x[!is.na(x)])
        )
      )

    DT::datatable(summary, rownames = FALSE, options = list(dom = "<t>", pageLength = dt_rows))
  } else if (is.factor(x) || is.character(x) || (is.numeric(x) && numeric_as_factor) || is.logical(x)) {

    # make sure factor is ordered numeric
    if (is.numeric(x)) {
      x <- factor(x, levels = sort(unique(x)))
    }

    level_counts <- table(x)
    max_levels_signif <- nchar(level_counts)

    if (!all(is.na(x))) {
      levels <- names(level_counts)
      counts <- sprintf(
        "%s [%.2f%%]",
        format(level_counts, width = max_levels_signif), prop.table(level_counts) * 100
      )
    } else {
      levels <- character(0)
      counts <- numeric(0)
    }

    summary <- data.frame(
      Level = levels,
      Count = counts,
      stringsAsFactors = FALSE
    )

    # sort the dataset in decreasing order of counts (needed as character variables default to alphabetical)
    summary <- summary[order(summary$Count, decreasing = TRUE), ]

    dom_opts <- if (nrow(summary) <= 10) {
      "<t>"
    } else {
      "<lf<t>ip>"
    }
    DT::datatable(summary, rownames = FALSE, options = list(dom = dom_opts, pageLength = dt_rows))
  } else if (inherits(x, "Date") || inherits(x, "POSIXct") || inherits(x, "POSIXlt")) {
    summary <-
      data.frame(
        Statistic = c("min", "median", "max"),
        Value = c(
          min(x, na.rm = TRUE),
          stats::median(x, na.rm = TRUE),
          max(x, na.rm = TRUE)
        )
      )
    DT::datatable(summary, rownames = FALSE, options = list(dom = "<t>", pageLength = dt_rows))
  } else {
    NULL
  }
}


#' Plot variable
#'
#' Creates summary plot with statistics relevant to data type.
#' @inheritParams shared_params
#' @param var vector of any type to be plotted. For numeric variables it produces histogram with
#' density line, for factors it creates frequency plot
#' @param var_lab text describing selected variable to be displayed on the plot
#' @param numeric_as_factor \code{logical} should the numeric variable be treated as a factor
#' @param display_density \code{logical} Should density estimation be displayed for numeric values?
#' @param remove_NA_hist \code{logical} Should \code{NA} values be removed for histogram of factor like variables.
#' @param outlier_definition If 0 no outliers are removed, otherwise
#'   outliers (those more than outlier_definition*IQR below/above Q1/Q3 be removed)
#' @param records_for_factor \code{numeric} if the number of factor levels is >= than this value then
#'   a graph of the factors isn't shown, only a list of values.
#' @return plot
#'
plot_var_summary <- function(var,
                             var_lab,
                             numeric_as_factor,
                             display_density = is.numeric(var),
                             remove_NA_hist = FALSE, # nolint
                             outlier_definition,
                             records_for_factor,
                             ggplot2_args) {
  checkmate::assert_flag(display_density)

  grid::grid.newpage()

  plot_main <- if (is.factor(var) || is.character(var) || is.logical(var)) {
    groups <- unique(as.character(var))
    len_groups <- length(groups)
    if (len_groups >= records_for_factor) {
      grid::textGrob(
        sprintf(
          "%s unique values\n%s:\n %s\n ...\n %s",
          len_groups,
          var_lab,
          paste(utils::head(groups), collapse = ",\n "),
          paste(utils::tail(groups), collapse = ",\n ")
        ),
        x = grid::unit(1, "line"),
        y = grid::unit(1, "npc") - grid::unit(1, "line"),
        just = c("left", "top")
      )
    } else {
      var <- if (isTRUE(remove_NA_hist)) as.vector(stats::na.omit(var)) else var
      ggplot(data.frame(var), aes(x = forcats::fct_infreq(as.factor(var)))) +
        geom_bar(stat = "count", aes(fill = ifelse(is.na(var), "withcolor", "")), show.legend = FALSE) +
        scale_fill_manual(values = c("gray50", "tan"))
    }
  } else if (is.numeric(var)) {
    validate(need(any(!is.na(var)), "No data left to visualize."))

    # Filter out NA
    var <- var[which(!is.na(var))]

    validate(need(!any(is.infinite(var)), "Cannot display graph when data includes infinite values"))

    if (numeric_as_factor) {
      var <- factor(var, levels = sort(unique(var)))
      p <- qplot(var)
    } else {
      # remove outliers
      if (outlier_definition != 0) {
        number_records <- length(var)
        var <- remove_outliers_from(var, outlier_definition)
        number_outliers <- number_records - length(var)
        outlier_text <- paste0(
          number_outliers, " outliers (",
          round(number_outliers / number_records * 100, 2),
          "% of non-missing records) not shown"
        )
        validate(need(
          length(var) > 1,
          "At least two data points must remain after removing outliers for this graph to be displayed"
        ))
      }
      ## histogram
      binwidth <- get_bin_width(var)
      p <- ggplot(data = data.frame(var = var), aes_string(x = "var", y = "..count..")) +
        geom_histogram(binwidth = binwidth) +
        scale_y_continuous(
          sec.axis = sec_axis(
            trans = ~ . / nrow(data.frame(var = var)),
            labels = scales::percent,
            name = "proportion (in %)"
          )
        )

      if (display_density) {
        p <- p + geom_density(aes_string(y = "..count.. * binwidth"))
      }

      if (outlier_definition != 0) {
        p <- p + annotate(
          geom = "text",
          label = outlier_text,
          x = Inf, y = Inf,
          hjust = 1.02, vjust = 1.2,
          color = "black"
        )
      }
      p
    }
  } else if (inherits(var, "Date") || inherits(var, "POSIXct") || inherits(var, "POSIXlt")) {
    var_num <- as.numeric(var)
    binwidth <- get_bin_width(var_num, 1)
    p <- ggplot(data = data.frame(var = var), aes_string(x = "var", y = "..count..")) +
      geom_histogram(binwidth = binwidth)
  } else {
    grid::textGrob(
      paste(strwrap(
        utils::capture.output(utils::str(var)),
        width = .9 * grid::convertWidth(grid::unit(1, "npc"), "char", TRUE)
      ), collapse = "\n"),
      x = grid::unit(1, "line"), y = grid::unit(1, "npc") - grid::unit(1, "line"), just = c("left", "top")
    )
  }

  dev_ggplot2_args <- teal.devel::ggplot2_args(
    labs = list(x = var_lab),
    theme = list(axis.text.x = element_text(angle = 45, hjust = 1))
  )

  all_ggplot2_args <- teal.devel::resolve_ggplot2_args(
    ggplot2_args,
    module_plot = dev_ggplot2_args
  )

  if (is.ggplot(plot_main)) {
    if (is.numeric(var) && !numeric_as_factor) {
      # numeric not as factor
      plot_main <- plot_main +
        theme_light() +
        list(labs = do.call("labs", all_ggplot2_args$labs))
    } else {
      # factor low number of levels OR numeric as factor OR Date
      plot_main <- plot_main +
        theme_light() +
        list(
          labs = do.call("labs", all_ggplot2_args$labs),
          theme = do.call("theme", all_ggplot2_args$theme)
        )
    }
    plot_main <- ggplotGrob(plot_main)
  }

  grid::grid.draw(plot_main)
  plot_main
}

#' Returns a short variable description.
#'
#' @description
#' The format of the variable description is:
#' <Long variable label> [<dataset name>.<variable name>]
#'
#' Example: Study Identifier [ADSL.STUDYID]
#'
#' @param datasets (`FilteredData`) the object containing the dataset
#' @param dataset_name (`character`) the name of the dataset containing the variable
#' @param var_name (`character`) the name of the variable
get_var_description <- function(datasets, dataset_name, var_name) {
  varlabel <- datasets$get_varlabels(dataname = dataset_name, var_name)
  d_var_name <- paste0(utils.nest::if_na(varlabel, var_name), " [", dataset_name, ".", var_name, "]")
  d_var_name
}

is_num_var_short <- function(.unique_records_for_factor, input, data_for_analysis) {
  length(unique(data_for_analysis()$data)) < .unique_records_for_factor && !is.null(input$numeric_as_factor)
}

#' Validates the variable browser inputs
#'
#' @param input (`session$input`) the shiny session input
#' @param plot_var (`list`) list of a data frame and an array of variable names
#' @param datasets (`FilteredData`) the datasets passed to the module
#'
#' @returns `logical` TRUE if validations pass; a Shiny validation error otherwise
validate_input <- function(input, plot_var, datasets) {
  reactive({
    dataset_name <- input$tabset_panel
    varname <- plot_var$variable[[input$tabset_panel]]
    type <- input$raw_or_filtered

    validate(need(dataset_name, "No data selected"))
    validate(need(varname, "No variable selected"))
    validate(need(is.logical(type), "Select what type of data to plot"))

    df <- datasets$get_data(dataset_name, filtered = type)
    teal.devel::validate_has_data(df, 1)
    teal.devel::validate_has_variable(varname = varname, data = df, "Variable not available")

    TRUE
  })
}

get_plotted_data <- function(input, plot_var, datasets) {
  dataset_name <- input$tabset_panel
  varname <- plot_var$variable[[input$tabset_panel]]
  type <- input$raw_or_filtered
  df <- datasets$get_data(dataset_name, filtered = type)

  var_description <- get_var_description(datasets = datasets, dataset_name = dataset_name, var_name = varname)
  list(data = df[[varname]], var_description = var_description)
}

#' Renders the left-hand side `tabset` panel of the module
#'
#' @param datanames (`character`) the name of the dataset
#' @param datasets (`FilteredData`) the object containing all datasets
#' @param input (`session$input`) the shiny session input
#' @param output (`session$output`) the shiny session output
#' @param columns_names (`environment`) the environment containing bindings for each dataset
#' @param plot_var (`list`) the list containing the currently selected dataset (tab) and its column names
render_tabset_panel_content <- function(datanames, output, datasets, input, columns_names, plot_var) {
  lapply(datanames, render_single_tab,
    input = input,
    output = output,
    datasets = datasets,
    columns_names = columns_names,
    plot_var = plot_var
  )
}

#' Renders a single tab in the left-hand side tabset panel
#'
#' @description
#' Renders a single tab in the left-hand side tabset panel. The rendered tab contains
#' information about one dataset out of many presented in the module.
#'
#' @param dataset_name (`character`) the name of the dataset contained in the rendered tab
#' @inheritParams render_tabset_panel_content
render_single_tab <- function(dataset_name, output, datasets, input, columns_names, plot_var) {
  render_tab_header(dataset_name, output, datasets)

  render_tab_table(
    dataset_name = dataset_name,
    output = output,
    datasets = datasets,
    input = input,
    columns_names = columns_names
  )
}

#' Renders the text headlining a single tab in the left-hand side tabset panel
#'
#' @param dataset_name (`character`) the name of the dataset of the tab
#' @inheritParams render_tabset_panel_content
#'
render_tab_header <- function(dataset_name, output, datasets) {
  dataset_ui_id <- paste0("dataset_summary_", dataset_name)
  output[[dataset_ui_id]] <- renderText({
    df <- datasets$get_data(dataset_name, filtered = FALSE)
    key <- datasets$get_keys(dataset_name)
    sprintf(
      "Dataset with %s unique key rows and %s variables",
      nrow(unique(`if`(length(key) > 0, df[, key, drop = FALSE], df))),
      ncol(df)
    )
  })
}

#' Renders the table for a single dataset in the left-hand side tabset panel
#'
#' @description
#' The table contains column names, column labels,
#' small summary about NA values and a sparkline (if appropriate).
#'
#' @param dataset_name (`character`) the name of the dataset
#' @inheritParams render_tabset_panel_content
#'
render_tab_table <- function(dataset_name, output, datasets, input, columns_names) {
  table_ui_id <- paste0("variable_browser_", dataset_name)

  output[[table_ui_id]] <- DT::renderDataTable(
    expr = {
      df <- datasets$get_data(dataset_name, filtered = FALSE)

      df_vars <- if (isTRUE(input$show_parent_vars)) {
        datasets$get_varnames(dataset_name)
      } else {
        datasets$get_filterable_varnames(dataset_name)
      }

      df <- df[df_vars]

      if (is.null(df) || ncol(df) == 0) {
        columns_names[[dataset_name]] <- character(0)
        data.frame(
          Type = character(0),
          Variable = character(0),
          Label = character(0),
          Missings = character(0),
          Sparklines = character(0),
          stringsAsFactors = FALSE
        )
      } else {
        # extract data variable labels
        labels <- stats::setNames(
          utils.nest::ulapply(
            df,
            function(x) {
              `if`(is.null(attr(x, "label")), "", attr(x, "label"))
            }
          ),
          names(df)
        )

        columns_names[[dataset_name]] <- names(labels)

        # calculate number of missing values
        missings <- vapply(
          df,
          var_missings_info,
          FUN.VALUE = character(1),
          USE.NAMES = FALSE
        )

        # get icons proper for the data types
        icons <- stats::setNames(teal:::variable_types(df), colnames(df))
        icons[intersect(datasets$get_keys(dataset_name), colnames(df))] <- "primary_key"
        icons <- teal:::variable_type_icons(icons)

        # generate sparklines
        sparklines_html <- vapply(
          df,
          create_sparklines,
          FUN.VALUE = character(1),
          USE.NAMES = FALSE
        )

        data.frame(
          Type = icons,
          Variable = names(labels),
          Label = labels,
          Missings = missings,
          Sparklines = sparklines_html,
          stringsAsFactors = FALSE
        )
      }
    },
    escape = FALSE,
    rownames = FALSE,
    selection = list(mode = "single", target = "row", selected = 1),
    options = list(
      fnDrawCallback = htmlwidgets::JS("function() { HTMLWidgets.staticRender(); }"),
      pageLength = input[[paste0(table_ui_id, "_rows")]]
    )
  )
}

#' Creates observers updating the currently selected column
#'
#' @description
#' The created observers update the column currently selected in the left-hand side
#' tabset panel.
#'
#' @note
#' Creates an observer for each dataset (each tab in the tabset panel).
#'
#' @inheritParams render_tabset_panel_content
establish_updating_selection <- function(datanames, input, plot_var, columns_names) {
  lapply(datanames, function(dataset_name) {
    table_ui_id <- paste0("variable_browser_", dataset_name)
    table_id_sel <- paste0(table_ui_id, "_rows_selected")
    observeEvent(input[[table_id_sel]], {
      plot_var$data <- dataset_name
      plot_var$variable[[dataset_name]] <- columns_names[[dataset_name]][input[[table_id_sel]]]
    })
  })
}

get_bin_width <- function(x_vec, scaling_factor = 2) {
  x_vec <- x_vec[!is.na(x_vec)]
  qntls <- stats::quantile(x_vec, probs = c(0.1, 0.25, 0.75, 0.9), type = 2)
  iqr <- qntls[3] - qntls[2]
  binwidth <- max(scaling_factor * iqr / length(x_vec) ^ (1 / 3), sqrt(qntls[4] - qntls[1])) # styler: off
  binwidth <- ifelse(binwidth == 0, 1, binwidth)
  # to ensure at least two bins when variable span is very small
  x_span <- diff(range(x_vec))
  if (isTRUE(x_span / binwidth >= 2)) binwidth else x_span / 2
}

custom_sparkline_formatter <- function(labels, counts) {
  htmlwidgets::JS(
    sprintf(
      "function(sparkline, options, field) {
        return 'ID: ' + %s[field[0].offset] + '<br>' + 'Count: ' + %s[field[0].offset];
        }",
      jsonlite::toJSON(labels),
      jsonlite::toJSON(counts)
    )
  )
}

#' Removes the outlier observation from an array
#'
#' @param var (`numeric`) a numeric vector
#' @param outlier_definition (`numeric`) if `0` then no outliers are removed, otherwise
#'   outliers (those more than `outlier_definition*IQR below/above Q1/Q3`) are removed
#' @returns (`numeric`) vector without the outlier values
remove_outliers_from <- function(var, outlier_definition) {
  q1_q3 <- stats::quantile(var, probs = c(0.25, 0.75), type = 2)
  iqr <- q1_q3[2] - q1_q3[1]
  var[var >= q1_q3[1] - outlier_definition * iqr & var <= q1_q3[2] + outlier_definition * iqr]
}
