#' Principal component analysis module
#' @md
#'
#' @inheritParams teal::module
#' @inheritParams teal.devel::standard_layout
#' @inheritParams shared_params
#' @param dat (`data_extract_spec` or `list` of multiple `data_extract_spec`)
#'   Datasets used to compute PCA.
#' @param alpha optional, (`numeric`) If scalar then the plot points will have a fixed opacity. If a
#'   slider should be presented to adjust the plot point opacity dynamically then it can be a vector of
#'   length three with `c(value, min, max)`.
#' @param size optional, (`numeric`) If scalar then the plot point sizes will have a fixed size.
#'   If a slider should be presented to adjust the plot point sizes dynamically then it can be a
#'   vector of length three with `c(value, min, max)`.
#' @param font_size optional, (`numeric`) font size control for title, x-axis label, y-axis label and legend.
#'   If scalar then the font size will have a fixed size. If a slider should be presented to adjust the plot
#'   point sizes dynamically then it can be a vector of length three with `c(value, min, max)`.
#'
#'
#' @export
#'
#' @examples
#'
#' # ADSL example
#'
#' library(scda)
#' ADSL <- synthetic_cdisc_data("latest")$adsl
#'
#' app <- teal::init(
#'   data = cdisc_data(cdisc_dataset(
#'    "ADSL", ADSL, code = "ADSL <- synthetic_cdisc_data(\"latest\")$adsl"
#'   ),
#'                     check = TRUE),
#'   modules = root_modules(
#'     tm_a_pca("PCA",
#'              data_extract_spec(
#'                dataname = "ADSL",
#'                select = select_spec(
#'                  choices = variable_choices(data = ADSL, c("BMRKR1", "AGE", "EOSDY")),
#'                  selected = c("BMRKR1", "AGE"),
#'                  multiple = TRUE
#'                ),
#'                filter = NULL
#'              )
#'     )
#'   )
#' )
#'
#' \dontrun{
#' shinyApp(app$ui, app$server)
#' }
#'
tm_a_pca <- function(label = "Principal Component Analysis",
                     dat,
                     plot_height = c(600, 200, 2000),
                     plot_width = NULL,
                     ggtheme = gg_themes,
                     rotate_xaxis_labels = FALSE,
                     font_size = c(12, 8, 20),
                     alpha = c(1, 0, 1),
                     size = c(2, 1, 8),
                     pre_output = NULL,
                     post_output = NULL) {
  logger::log_info("Initializing tm_a_pca")
  stopifnot(is_character_single(label))
  stopifnot(is_class_list("data_extract_spec")(dat) || is(dat, "data_extract_spec"))

  ggtheme <- match.arg(ggtheme)
  stopifnot(is_character_single(ggtheme))
  stopifnot(is_logical_single(rotate_xaxis_labels))

  check_slider_input(alpha, allow_null = FALSE, allow_single = TRUE, min = 0, max = 1)
  check_slider_input(size, allow_null = FALSE, allow_single = TRUE, min = 1, max = 8)
  check_slider_input(font_size, allow_null = FALSE, allow_single = TRUE, min = 8, max = 20)

  check_slider_input(plot_height, allow_null = FALSE)
  check_slider_input(plot_width)

  if (!is_class_list("data_extract_spec")(dat)) {
    dat <- list(dat)
  }

  args <- as.list(environment())

  data_extract_list <- list(dat = dat)

  module(
    label = label,
    server = srv_a_pca,
    ui = ui_a_pca,
    ui_args = args,
    server_args = c(data_extract_list, list(plot_height = plot_height, plot_width = plot_width)),
    filters = get_extract_datanames(data_extract_list)
  )
}


ui_a_pca <- function(id, ...) {
  ns <- NS(id)
  args <- list(...)
  is_single_dataset_value <- is_single_dataset(args$dat)

  color_selector <- args$dat
  for (i in seq_along(color_selector)) {
    color_selector[[i]]$select$multiple <- FALSE
    color_selector[[i]]$select$always_selected <- NULL
    color_selector[[i]]$select$selected <- NULL
  }

  plot_choices <- c(
    "Elbow plot" = "elbow",
    "Circle plot" = "circle",
    "Biplot" = "biplot",
    "Eigenvector plot" = "pc_var"
  )

  standard_layout(
    output = white_small_well(
      tags$div(
        uiOutput(ns("tbl_importance_ui")),
        hr(),
        uiOutput(ns("tbl_eigenvector_ui")),
        hr(),
        plot_with_settings_ui(id = ns("pca_plot"))
      )
    ),
    encoding = div(
      tags$label("Encodings", class = "text-primary"),
      datanames_input(args["dat"]),
      data_extract_input(
        id = ns("dat"),
        label = "Data selection",
        data_extract_spec = args$dat,
        is_single_dataset = is_single_dataset_value
      ),
      panel_group(
        panel_item(
          title = "Display",
          collapsed = FALSE,
          checkboxGroupInput(
            ns("tables_display"),
            "Tables display",
            choices = c("PC importance" = "importance", "Eigenvectors" = "eigenvector"),
            selected = c("importance", "eigenvector")
          ),
          radioButtons(
            ns("plot_type"),
            label = "Plot type",
            choices = plot_choices,
            selected = plot_choices["Elbow plot"]
          )
        ),
        panel_item(
          title = "Pre-processing",
          radioButtons(
            ns("standardization"), "Standardization",
            choices = c("None" = "none", "Center" = "center", "Center & Scale" = "center_scale"),
            selected = "center_scale"),
          radioButtons(
            ns("na_action"), "NA action",
            choices = c("None" = "none", "Drop" = "drop"),
            selected = "none")
        ),
        panel_item(
          title = "Selected plot specific settings",
          collapsed = FALSE,
          uiOutput(ns("plot_settings")),
          conditionalPanel(
            condition = paste0("input['", ns("plot_type"), "'] == 'biplot'"),
            list(
              data_extract_input(
                id = ns("response"),
                label = "Color by",
                data_extract_spec = color_selector,
                is_single_dataset = is_single_dataset_value
              ),
              optionalSliderInputValMinMax(ns("alpha"), "Opacity:", args$alpha, ticks = FALSE),
              optionalSliderInputValMinMax(ns("size"), "Points size:", args$size, ticks = FALSE)
            )
          )
        ),
        panel_item(
          title = "Plot settings",
          collapsed = TRUE,
          conditionalPanel(
            condition =
              paste0("input['", ns("plot_type"), "'] == 'elbow' || input['", ns("plot_type"), "'] == 'pc_var'"),
            list(
              checkboxInput(ns("rotate_xaxis_labels"), "Rotate X axis labels", value = args$rotate_xaxis_labels)
              )
            ),
          optionalSelectInput(
            inputId = ns("ggtheme"),
            label = "Theme (by ggplot):",
            choices = gg_themes,
            selected = gg_themes[1],
            multiple = FALSE
          ),
          optionalSliderInputValMinMax(ns("font_size"),  "Font Size", args$font_size, ticks = FALSE)
        )
      )
    ),
    forms = get_rcode_ui(ns("rcode")),
    pre_output = args$pre_output,
    post_output = args$post_output
  )
}

srv_a_pca <- function(input, output, session, datasets, dat, plot_height, plot_width) {
  response <- dat

  for (i in seq_along(response)) {
    response[[i]]$select$multiple <- FALSE
    response[[i]]$select$always_selected <- NULL
    response[[i]]$select$selected <- NULL
    response[[i]]$select$choices <- names(datasets$get_data_attr(response[[i]]$dataname, "column_labels"))
    response[[1]]$select$choices <- setdiff(response[[1]]$select$choices,
                                            datasets$get_keys(response[[i]]$dataname))
  }

  init_chunks()

  anl_data <- data_merge_module(
    datasets = datasets,
    data_extract = list(dat = dat)
  )

  response_data <- data_merge_module(
    datasets = datasets,
    data_extract = list(response),
    input_id = c("response"),
    anl_name = "RP"
  )

  # computation ----
  computation <- reactive({
    chunks_stack <- chunks$new()

    keep_cols <- as.character(anl_data()$columns_source$dat)
    na_action <- input$na_action
    standardization <- input$standardization
    center <- standardization %in% c("center", "center_scale") #nolint
    scale <- standardization == "center_scale"

    validate(need(length(keep_cols) > 1, "Please select more than 1 variable to perform PCA."))

    chunks_reset(chunks = chunks_stack)
    chunks_push_chunks(anl_data()$chunks, chunks = chunks_stack)

    ANL <- anl_data()$data() #nolint

    validate_has_data(ANL, 10)
    validate_has_elements(keep_cols, "Please select columns")
    validate(need(
      all(vapply(ANL[keep_cols], function(x) is.numeric(x) && !is.infinite(x), logical(1))),
      "PCA is only defined for (finite) numeric columns."
    ))
    validate(need(
      na_action != "none" | !anyNA(ANL[keep_cols]),
      paste("There are NAs in the dataset. Please deal with them in preprocessing",
            'or select "Drop" in the NA actions inside the encodings panel (left).')
    ))

    chunks_push(
      id = "pca_1",
      expression = substitute(
        expr = {
          keep_columns <- keep_cols
        },
        env = list(
          keep_cols = keep_cols
        )
      ),
      chunks = chunks_stack
    )

    if (na_action == "drop") {
      chunks_push(
        id = "pca_2",
        expression = substitute(
          expr = ANL <- tidyr::drop_na(ANL, keep_columns), # nolint
          env = list()
        ),
        chunks = chunks_stack
      )
    }

    if (scale) {
      chunks_validate_custom(
        substitute(
          expr = vapply(ANL[keep_cols], function(column) length(unique(column)) != 1, FUN.VALUE = logical(1)),
          env = list(keep_cols = keep_cols)
        ),
        msg = paste0(
          "You have selected `Center & Scale` under `Standardization` in the `Pre-processing` panel, ",
          "but one or more of your columns has/have a variance value of zero, indicating all values are identical"),
        chunks = chunks_stack
      )
    }

    chunks_push(
      id = "pca_3",
      expression = substitute(
        expr = pca <- summary(prcomp(ANL[keep_columns], center = center, scale. = scale, retx = TRUE)),
        env = list(center = center, scale = scale)
      ),
      chunks = chunks_stack
    )

    chunks_push(
      id = "pca_tbl_importance",
      expression = quote({
        tbl_importance <- dplyr::as_tibble(pca$importance, rownames = "Metric")
        tbl_importance
      }),
      chunks = chunks_stack
    )

    chunks_push(
      id = "pca_tbl_eigenvector",
      expression = quote({
        tbl_eigenvector <- dplyr::as_tibble(pca$rotation, rownames = "Variable")
        tbl_eigenvector
      }),
      chunks = chunks_stack
    )

    chunks_safe_eval(chunks = chunks_stack)

    chunks_stack
  })

  # plot args ----
  output$plot_settings <- renderUI({
    # reactivity triggers
    chunks_stack <- computation()

    ns <- session$ns

    pca <- chunks_get_var("pca", chunks = chunks_stack)
    chcs_pcs <- colnames(pca$rotation)
    chcs_vars <- chunks_get_var("keep_cols", chunks = chunks_stack)

    tagList(
      conditionalPanel(
        condition = paste0("input['", ns("plot_type"), "'] == 'biplot' || input['", ns("plot_type"), "'] == 'circle'"),
        list(
          optionalSelectInput(ns("x_axis"), "X axis", choices = chcs_pcs, selected = chcs_pcs[1]),
          optionalSelectInput(ns("y_axis"), "Y axis", choices = chcs_pcs, selected = chcs_pcs[2]),
          optionalSelectInput(
            ns("variables"), "Original coordinates",
            choices = chcs_vars, selected = chcs_vars,
            multiple = TRUE)
        )
      ),
      conditionalPanel(
        condition = paste0("input['", ns("plot_type"), "'] == 'elbow'"),
        helpText("No plot specific settings available.")
      ),
      conditionalPanel(
        condition = paste0("input['", ns("plot_type"), "'] == 'pc_var'"),
        optionalSelectInput(ns("pc"), "PC", choices = chcs_pcs, selected = chcs_pcs[1])
      )
    )
  })

  # plot elbow ----
  plot_elbow <- function() {
    ggtheme <- input$ggtheme
    validate(need(ggtheme, "Please select a theme."))
    rotate_xaxis_labels <- input$rotate_xaxis_labels #nolint
    font_size <- input$font_size #nolint

    chunks_push(
      id = "pca_plot",
      expression = substitute(
        expr = {
          elb_dat <- pca$importance[c("Proportion of Variance", "Cumulative Proportion"), ] %>%
            dplyr::as_tibble(rownames = "metric") %>%
            tidyr::gather("component", "value", -metric) %>%
            dplyr::mutate(component = factor(component, levels = unique(stringr::str_sort(component, numeric = T))))

          g <- ggplot(mapping = aes_string(x = "component", y = "value")) +
            geom_bar(
              aes(fill = "Single variance"),
              data = dplyr::filter(elb_dat, metric == "Proportion of Variance"),
              color = "black",
              stat = "identity") +
            geom_point(
              aes(color = "Cumulative variance"),
              data = dplyr::filter(elb_dat, metric == "Cumulative Proportion")) +
            geom_line(
              aes(group = 1, color = "Cumulative variance"),
              data = dplyr::filter(elb_dat, metric == "Cumulative Proportion")) +
            ggtheme_call +
            labs(x = "Principal component", y = "Proportion of variance explained", color = "", fill = "Legend") +
            scale_color_manual(values = c("Cumulative variance" = "darkred", "Single variance" = "black")) +
            scale_fill_manual(values = c("Cumulative variance" = "darkred", "Single variance" = "lightblue")) +
            theme(
              legend.position = "right",
              legend.spacing.y = unit(-5, "pt"),
              legend.title = element_text(vjust = 8)) +
            theme(axis.text.x = element_text(angle = angle_value, hjust = hjust_value)) +
            theme(text = element_text(size = font_size))

          print(g)
        },
        env = list(
          ggtheme_call = call(paste0("theme_", ggtheme)),
          angle_value = ifelse(rotate_xaxis_labels, 45, 0),
          hjust_value = ifelse(rotate_xaxis_labels, 1, 0.5),
          font_size = font_size
        )
      )
    )

    invisible(NULL)
  }

  # plot circle ----
  plot_circle <- function() {
    validate(
      need(input$x_axis, "Need additional plot settings - x axis"),
      need(input$y_axis, "Need additional plot settings - y axis"),
      need(input$variables, "Need additional plot settings - variables"))
    validate(need(input$x_axis != input$y_axis, "Please choose different X and Y axes."))

    x_axis <- input$x_axis #nolint
    y_axis <- input$y_axis #nolint
    variables <- input$variables #nolint

    ggtheme <- input$ggtheme
    validate(need(ggtheme, "Please select a theme."))

    rotate_xaxis_labels <- input$rotate_xaxis_labels #nolint
    font_size <- input$font_size #nolint

    chunks_push(
      id = "pca_plot",
      expression = substitute(
        expr = {
          pca_rot <- pca$rotation[, c(x_axis, y_axis)] %>%
            dplyr::as_tibble(rownames = "label") %>%
            dplyr::filter(label %in% variables)

          circle_data <- data.frame(
            x = cos(seq(0, 2 * pi, length.out = 100)),
            y = sin(seq(0, 2 * pi, length.out = 100))
          )

          g <- ggplot(pca_rot) +
            geom_point(aes_string(x = x_axis, y = y_axis)) +
            geom_label(
              aes_string(x = x_axis, y = y_axis, label = "label"),
              nudge_x = 0.1, nudge_y = 0.05,
              fontface = "bold") +
            geom_path(aes(x, y, group = 1), data = circle_data) +
            geom_point(aes(x = x, y = y), data = data.frame(x = 0, y = 0), shape = "x", size = 5) +
            ggtheme_call +
            theme(axis.text.x = element_text(angle = angle, hjust = hjust)) +
            theme(text = element_text(size = font_size))
          print(g)
        },
        env = list(
          x_axis = x_axis,
          y_axis = y_axis,
          variables = variables,
          ggtheme_call = call(paste0("theme_", ggtheme)),
          angle = ifelse(rotate_xaxis_labels, 45, 0),
          hjust = ifelse(rotate_xaxis_labels, 1, 0.5),
          font_size = font_size
        )
      )
    )

    invisible(NULL)
  }

  # plot biplot ----
  plot_biplot <- function() {
    validate(
      need(input$x_axis, "Need additional plot settings - x axis"),
      need(input$y_axis, "Need additional plot settings - y axis"))
    validate(need(isTRUE(input$x_axis != input$y_axis), "Please choose different X and Y axes."))

    rd <- response_data()
    resp_col <- as.character(rd$columns_source$response)
    x_axis <- input$x_axis #nolint
    y_axis <- input$y_axis #nolint
    variables <- input$variables #nolint
    pca <- chunks_get_var("pca")

    ggtheme <- input$ggtheme
    validate(need(ggtheme, "Please select a theme."))

    rotate_xaxis_labels <- input$rotate_xaxis_labels #nolint
    alpha <- input$alpha # nolint
    size <- input$size # nolint
    font_size <- input$font_size #nolint

    chunks_push(
      id = "pca_plot_data_rot",
      expression = substitute(
        expr = pca_rot <- dplyr::as_tibble(pca$x[, c(x_axis, y_axis)]),
        env = list(x_axis = x_axis, y_axis = y_axis)
      )
    )

    # rot_vars = data frame that displays arrows in the plot, need to be scaled to data
    if (!is.null(input$variables)) {
      chunks_push(
        id = "pca_plot_vars_rot_1",
        expression = substitute(
          expr = {
            r <- sqrt(qchisq(0.69, df = 2)) * prod(colMeans(pca_rot ^ 2)) ^ (1 / 4)
            v_scale <- rowSums(pca$rotation ^ 2)

            rot_vars <- pca$rotation[, c(x_axis, y_axis)] %>%
              dplyr::as_tibble(rownames = "label") %>%
              dplyr::mutate_at(vars(c(x_axis, y_axis)), function(x) r * x / sqrt(max(v_scale)))
          },
          env = list(x_axis = x_axis, y_axis = y_axis)
        )
      )

      # determine start of arrows
      chunks_push(
        id = "pca_plot_vars_rot_2",
        expression = if (is.logical(pca$center) && !pca$center) {
          substitute(
            expr = {
              rot_vars <- rot_vars %>%
                tibble::column_to_rownames("label") %>%
                sweep(1, apply(ANL[keep_columns], 2, mean, na.rm = TRUE)) %>%
                tibble::rownames_to_column("label") %>%
                dplyr::mutate(xstart = mean(pca$x[, x_axis], na.rm = TRUE),
                              ystart = mean(pca$x[, y_axis], na.rm = TRUE))
            },
            env = list(x_axis = x_axis, y_axis = y_axis)
          )
        } else {
          quote(rot_vars <- rot_vars %>% dplyr::mutate(xstart = 0, ystart = 0))
        }
      )

      chunks_push(
        id = "pca_plot_vars_rot_3",
        expression = substitute(
          expr = rot_vars <- rot_vars %>% dplyr::filter(label %in% variables),
          env = list(variables = variables)
        )
      )
    }

    if (length(resp_col) == 0) {
      chunks_push(
        id = "pca_plot_biplot",
        substitute(
          expr = {
            g <- ggplot() +
              geom_point(aes_string(x = x_axis, y = y_axis), data = pca_rot, alpha = alpha, size = size) +
              ggtheme_call +
              theme(axis.text.x = element_text(angle = angle, hjust = hjust)) +
              theme(text = element_text(size = font_size))
          },
          env = list(
            x_axis = x_axis,
            y_axis = y_axis,
            alpha = alpha,
            size = size,
            ggtheme_call = call(paste0("theme_", ggtheme)),
            angle = ifelse(rotate_xaxis_labels, 45, 0),
            hjust = ifelse(rotate_xaxis_labels, 1, 0.5),
            font_size = font_size
          )
        )
      )
    } else {
      ANL <- chunks_get_var("ANL") # nolint
      validate(need(
        !resp_col %in% colnames(ANL),
        "Response column must be different from the original variables (that were used for PCA)."))

      rp <- chunks_get_var("RP")
      rp_keys <- setdiff(colnames(rp), as.character(unlist(rd$columns_source))) # nolint

      response <- rp[[resp_col]]

      chunks_push(
        id = "pca_plot_response",
        expression = if (is.character(response) ||
                         is.factor(response) ||
                         (is.numeric(response) && length(unique(response)) <= 6)) {
          substitute(
            expr = {
              response <- RP[[resp_col]]
              pca_rot$response <- as.factor(response)
              scale_colors <- scale_color_brewer(palette = "Dark2")
              aes_biplot <- aes_string(x = x_axis, y = y_axis, color = "response")
            },
            env = list(resp_col = resp_col, x_axis = x_axis, y_axis = y_axis)
          )
        } else if (class(response) == "Date") {
          substitute(
            expr = {
              response <- RP[[resp_col]]
              pca_rot$response <- as.numeric(response)
              scale_colors <- scale_color_gradient(
                low = "darkred",
                high = "lightblue",
                labels = function(x) as.Date(x, origin = "1970-01-01"))
              aes_biplot <- aes_string(x = x_axis, y = y_axis, color = "response")
            },
            env = list(resp_col = resp_col, x_axis = x_axis, y_axis = y_axis)
          )
        } else {
          substitute(
            expr = {
              response <- RP[[resp_col]]
              pca_rot$response <- response
              scale_colors <- scale_color_gradient(low = "darkred", high = "lightblue")
              aes_biplot <- aes_string(x = x_axis, y = y_axis, color = "response")
            },
            env = list(resp_col = resp_col, x_axis = x_axis, y_axis = y_axis)
          )
        }
      )

      chunks_push(
        id = "pca_plot_biplot",
        expression = substitute(
          expr = {
            g <- ggplot() +
              geom_point(aes_biplot, data = pca_rot, alpha = alpha, size = size) +
              scale_colors +
              ggtheme_call +
              labs(color = color) +
              theme(axis.text.x = element_text(angle = angle, hjust = hjust)) +
              theme(text = element_text(size = font_size))
          },
          env = list(
            alpha = alpha,
            size = size,
            ggtheme_call = call(paste0("theme_", ggtheme)),
            color = varname_w_label(resp_col, rp),
            angle = ifelse(rotate_xaxis_labels, 45, 0),
            hjust = ifelse(rotate_xaxis_labels, 1, 0.5),
            font_size = font_size
          )
        )
      )
    }

    if (!is.null(input$variables)) {
      chunks_push(
        id = "pca_plot_arrow_plot",
        expression = substitute(
          expr = {
            g <- g +
              geom_segment(
                aes_string(x = "xstart", y = "ystart", xend = x_axis, yend = y_axis),
                data = rot_vars,
                lineend = "round", linejoin = "round",
                arrow = arrow(length = unit(0.5, "cm"))) +
              geom_label(
                aes_string(x = x_axis, y = y_axis, label = "label"),
                data = rot_vars,
                nudge_y = 0.1,
                fontface = "bold") +
              geom_point(aes(x = xstart, y = ystart), data = rot_vars, shape = "x", size = 5)
          },
          env = list(x_axis = x_axis, y_axis = y_axis)
        )
      )
    }

    chunks_push(
      id = "pca_plot_final",
      expression = quote(print(g))
    )

    invisible(NULL)
  }

  # plot pc_var ----
  plot_pc_var <- function() {
    validate(need(input$pc, "Need additional plot settings - PC"))

    pc <- input$pc #nolint

    ggtheme <- input$ggtheme
    validate(need(ggtheme, "Please select a theme."))

    rotate_xaxis_labels <- input$rotate_xaxis_labels #nolint
    font_size <- input$font_size #nolint

    chunks_push(
      id = "pca_plot",
      expression = substitute(
        expr = {
          pca_rot <- pca$rotation[, pc, drop = FALSE] %>%
            dplyr::as_tibble(rownames = "Variable")

          g <- ggplot(pca_rot) +
            geom_bar(aes_string(x = "Variable", y = pc), stat = "identity", color = "black", fill = "lightblue") +
            geom_text(
              aes_q(
                x = quote(Variable),
                y = as.name(pc),
                label = quote(round(pc_sym, 3)),
                vjust = quote(ifelse(pc_sym > 0, -0.5, 1.3))
              )
            ) +
            ggtheme_call +
            theme(axis.text.x = element_text(angle = angle, hjust = hjust)) +
            theme(text = element_text(size = font_size))

          print(g)
        },
        env = list(
          pc = pc,
          pc_sym = rlang::sym(pc),
          ggtheme_call = call(paste0("theme_", ggtheme)),
          angle = ifelse(rotate_xaxis_labels, 45, 0),
          hjust = ifelse(rotate_xaxis_labels, 1, 0.5),
          font_size = font_size
        )
      )
    )

    invisible(NULL)
  }

  # plot final ----
  plot_r <- reactive({
    chunks_reset()
    chunks_push_chunks(computation())

    if (input$plot_type == "elbow") {
      plot_elbow()

    } else if (input$plot_type == "circle") {
      plot_circle()

    } else if (input$plot_type == "biplot") {
      if (length(response_data()$columns_source$response) > 0) {
        chunks_push_chunks(response_data()$chunks, overwrite = TRUE)
      }

      plot_biplot()

    } else if (input$plot_type == "pc_var") {
      plot_pc_var()

    } else {
      stop("Unknown plot")
    }

    chunks_safe_eval()
  })

  callModule(
    plot_with_settings_srv,
    id = "pca_plot",
    plot_r = plot_r,
    height = plot_height,
    width = plot_width,
    graph_align = "center"
  )

  # tables ----
  output$tbl_importance <- renderTable({
    req("importance" %in% input$tables_display)
    chunks_stack <- computation()
    chunks_get_var("tbl_importance", chunks = chunks_stack)
  }, bordered = TRUE, align = "c", digits = 3)

  output$tbl_importance_ui <- renderUI({
    req("importance" %in% input$tables_display)
    div(
      tags$h4("Principal components importance"),
      tableOutput(session$ns("tbl_importance")),
      align = "center"
    )
  })

  output$tbl_eigenvector <- renderTable({
    req("eigenvector" %in% input$tables_display)
    chunks_stack <- computation()
    chunks_get_var("tbl_eigenvector", chunks = chunks_stack)
  }, bordered = TRUE, align = "c", digits = 3)

  output$tbl_eigenvector_ui <- renderUI({
    req("eigenvector" %in% input$tables_display)
    div(
      tags$h4("Eigenvectors"),
      tableOutput(session$ns("tbl_eigenvector")),
      align = "center"
    )
  })


  callModule(
    get_rcode_srv,
    id = "rcode",
    datasets = datasets,
    datanames = get_extract_datanames(list(dat)),
    modal_title = "R code for PCA"
  )
}
